<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const scoreEl = document.getElementById("score");
const bestEl = document.getElementById("best");
const starsEl = document.getElementById("stars");
const difficultyEl = document.getElementById("difficulty");

const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const rand = (a, b) => a + Math.random() * (b - a);

const DIFFICULTIES = {
  easy:   { enemySpeedMult: 0.85, spawnMult: 0.80, scoreMult: 0.90 },
  normal: { enemySpeedMult: 1.00, spawnMult: 1.00, scoreMult: 1.00 },
  hard:   { enemySpeedMult: 1.20, spawnMult: 1.25, scoreMult: 1.15 },
};

const state = {
  running: false,
  paused: false,
  gameOver: false,
  startedOnce: false,

  t: 0,
  score: 0,
  best: Number(localStorage.getItem("dodge_best") || 0),
  lastTime: performance.now(),

  keys: new Set(),

  hazards: [],
  spawnTimer: 0,

  stars: [],
  starTimer: 30,
  starsCollected: 0,

  shields: [],
  shieldTimer: 22,

  difficultyKey: "normal",
  difficultyRamp: 1,
};

bestEl.textContent = String(state.best);
starsEl.textContent = "0";

const player = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  r: 14,
  baseSpeed: 260,

  speedBoostTimer: 0, // ‚≠ê 5s speed boost
  shieldTimer: 0,     // üõ° 5s immunity
};

function reset(toStartScreen = true) {
  state.paused = false;
  state.gameOver = false;

  state.t = 0;
  state.score = 0;
  state.spawnTimer = 0;

  state.hazards = [];
  state.stars = [];
  state.shields = [];

  state.starTimer = 30;   // ‚≠ê every 30s
  state.shieldTimer = 22; // üõ° separate powerup

  state.starsCollected = 0;
  starsEl.textContent = "0";
  scoreEl.textContent = "0";

  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  player.speedBoostTimer = 0;
  player.shieldTimer = 0;

  state.running = !toStartScreen;
}

function startGame() {
  if (state.gameOver) return;
  state.running = true;
  state.startedOnce = true;
  state.paused = false;
}

function spawnHazard() {
  const side = Math.floor(rand(0, 4));
  const size = rand(18, 44);
  let x, y;

  if (side === 0) { x = rand(0, canvas.width); y = -size; }
  else if (side === 1) { x = canvas.width + size; y = rand(0, canvas.height); }
  else if (side === 2) { x = rand(0, canvas.width); y = canvas.height + size; }
  else { x = -size; y = rand(0, canvas.height); }

  const dx = player.x - x;
  const dy = player.y - y;
  const mag = Math.hypot(dx, dy) || 1;

  const diff = DIFFICULTIES[state.difficultyKey] || DIFFICULTIES.normal;
  const ramp = 1 + (state.difficultyRamp - 1) * 0.18;
  const speed = rand(140, 220) * ramp * diff.enemySpeedMult;

  state.hazards.push({
    x, y, w: size, h: size,
    vx: (dx / mag) * speed + rand(-25, 25),
    vy: (dy / mag) * speed + rand(-25, 25),
    rot: rand(0, Math.PI * 2),
    vr: rand(-2, 2),
  });
}

function spawnStar() {
  state.stars.push({
    x: rand(60, canvas.width - 60),
    y: rand(60, canvas.height - 60),
    r: 12,
    spin: rand(0, Math.PI * 2),
    pulse: rand(0, Math.PI * 2),
  });
}

function spawnShield() {
  state.shields.push({
    x: rand(60, canvas.width - 60),
    y: rand(60, canvas.height - 60),
    r: 14,
    pulse: rand(0, Math.PI * 2),
  });
}

function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
  const closestX = clamp(cx, rx, rx + rw);
  const closestY = clamp(cy, ry, ry + rh);
  const dx = cx - closestX;
  const dy = cy - closestY;
  return (dx * dx + dy * dy) <= cr * cr;
}

// ‚≠ê Proper star shape (with moveTo so the path is valid everywhere)
function drawStar(x, y, outerR, innerR, rotation) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  ctx.beginPath();
  for (let i = 0; i < 10; i++) {
    const r = (i % 2 === 0) ? outerR : innerR;
    const a = (Math.PI / 5) * i - Math.PI / 2;
    const px = Math.cos(a) * r;
    const py = Math.sin(a) * r;

    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function gameOver() {
  state.running = false;
  state.gameOver = true;

  const s = Math.floor(state.score);
  if (s > state.best) {
    state.best = s;
    localStorage.setItem("dodge_best", String(s));
    bestEl.textContent = String(s);
  }
}

function update(dt) {
  if (!state.running || state.paused || state.gameOver) return;

  const diff = DIFFICULTIES[state.difficultyKey] || DIFFICULTIES.normal;

  state.t += dt;
  state.difficultyRamp = 1 + state.t / 18;

  state.score += dt * 10 * diff.scoreMult;
  scoreEl.textContent = String(Math.floor(state.score));

  if (player.speedBoostTimer > 0) player.speedBoostTimer -= dt;
  if (player.shieldTimer > 0) player.shieldTimer -= dt;

  // movement (WASD only)
  const boosting = state.keys.has("shift");
  const boostPower = (player.speedBoostTimer > 0) ? 1.6 : 1.0;
  const speed = player.baseSpeed * (boosting ? 1.45 : 1.0) * boostPower;

  let mx = 0, my = 0;
  if (state.keys.has("a")) mx -= 1;
  if (state.keys.has("d")) mx += 1;
  if (state.keys.has("w")) my -= 1;
  if (state.keys.has("s")) my += 1;

  const mag = Math.hypot(mx, my);
  if (mag > 0) {
    player.x += (mx / mag) * speed * dt;
    player.y += (my / mag) * speed * dt;
  }

  player.x = clamp(player.x, player.r, canvas.width - player.r);
  player.y = clamp(player.y, player.r, canvas.height - player.r);

  // hazards
  state.spawnTimer -= dt;
  const spawnEvery = (0.9 / diff.spawnMult);
  if (state.spawnTimer <= 0) {
    spawnHazard();
    if (state.difficultyKey === "hard" && Math.random() < 0.10) spawnHazard();
    state.spawnTimer = spawnEvery;
  }

  // ‚≠ê star every 30s
  state.starTimer -= dt;
  if (state.starTimer <= 0) {
    spawnStar();
    state.starTimer = 30;
  }

  // üõ° shield powerup
  state.shieldTimer -= dt;
  if (state.shieldTimer <= 0) {
    spawnShield();
    state.shieldTimer = 22;
  }

  for (const h of state.hazards) {
    h.x += h.vx * dt;
    h.y += h.vy * dt;
    h.rot += h.vr * dt;
  }

  // collect stars => speed boost 5s
  state.stars = state.stars.filter(s => {
    s.spin += dt * 2.0;
    s.pulse += dt * 6.0;
    if (Math.hypot(player.x - s.x, player.y - s.y) < player.r + s.r) {
      player.speedBoostTimer = 5;
      state.score += 50;
      state.starsCollected += 1;
      starsEl.textContent = String(state.starsCollected);
      return false;
    }
    return true;
  });

  // collect shields => immunity 5s
  state.shields = state.shields.filter(s => {
    s.pulse += dt * 5.0;
    if (Math.hypot(player.x - s.x, player.y - s.y) < player.r + s.r) {
      player.shieldTimer = 5;
      return false;
    }
    return true;
  });

  // collision (only if no shield)
  if (player.shieldTimer <= 0) {
    for (const h of state.hazards) {
      if (circleRectCollide(player.x, player.y, player.r, h.x, h.y, h.w, h.h)) {
        gameOver();
        break;
      }
    }
  }
}

function overlay(title, subtitle) {
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#e8ecff";
  ctx.textAlign = "center";
  ctx.font = "700 42px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(title, canvas.width / 2, canvas.height / 2 - 10);
  ctx.font = "400 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.globalAlpha = 0.9;
  ctx.fillText(subtitle, canvas.width / 2, canvas.height / 2 + 28);
  ctx.restore();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // hazards
  for (const h of state.hazards) {
    ctx.save();
    ctx.translate(h.x + h.w / 2, h.y + h.h / 2);
    ctx.rotate(h.rot);
    ctx.fillStyle = "rgba(255,90,120,0.95)";
    ctx.fillRect(-h.w / 2, -h.h / 2, h.w, h.h);
    ctx.restore();
  }

  // ‚≠ê stars (shaped)
  for (const s of state.stars) {
    const pulse = 1 + Math.sin(s.pulse) * 0.12;

    // glow
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(255,217,102,1)";
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r * 2.0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = "rgba(255,217,102,0.98)";
    drawStar(s.x, s.y, s.r * pulse, (s.r * 0.5) * pulse, s.spin);
  }

  // üõ° shields on map
  for (const s of state.shields) {
    const pulse = 1 + Math.sin(s.pulse) * 0.08;

    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#66b3ff";
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r * 2.1 * pulse, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r * pulse, 0, Math.PI * 2);
    ctx.strokeStyle = "#66b3ff";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // player
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fillStyle = (player.speedBoostTimer > 0) ? "#a6ff7c" : "#7cf7ff";
  ctx.fill();

  // üõ° active shield ring (glowing)
  if (player.shieldTimer > 0) {
    const wobble = 1 + Math.sin(state.t * 8) * 0.05;

    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#66b3ff";
    ctx.beginPath();
    ctx.arc(player.x, player.y, (player.r + 14) * wobble, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.beginPath();
    ctx.arc(player.x, player.y, (player.r + 12) * wobble, 0, Math.PI * 2);
    ctx.strokeStyle = "#66b3ff";
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  // overlays
  if (!state.startedOnce && !state.running && !state.gameOver) {
    overlay("Dodge the Blocks", "Choose difficulty, then press Enter / Space to start");
  } else if (state.paused) {
    overlay("Paused", "Press P to resume");
  } else if (state.gameOver) {
    overlay("Game Over", "Press R to restart");
  }
}

function loop(now) {
  const dt = Math.min(0.033, (now - state.lastTime) / 1000);
  state.lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// difficulty change => back to start screen
difficultyEl.addEventListener("change", () => {
  state.difficultyKey = difficultyEl.value;
  state.startedOnce = false;
  reset(true);
});

// input
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();

  if (k === "enter" || k === " ") {
    startGame();
    e.preventDefault();
    return;
  }
  if (k === "p") {
    if (state.startedOnce && !state.gameOver) state.paused = !state.paused;
    e.preventDefault();
    return;
  }
  if (k === "r") {
    state.startedOnce = false;
    reset(true);
    e.preventDefault();
    return;
  }

  state.keys.add(k);
});

window.addEventListener("keyup", (e) => {
  state.keys.delete(e.key.toLowerCase());
});

// start screen
reset(true);
requestAnimationFrame(loop);
</script>
